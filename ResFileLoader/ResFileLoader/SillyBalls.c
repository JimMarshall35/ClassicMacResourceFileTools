#include <Types.h>#include <Memory.h>#include <Quickdraw.h>#include <Fonts.h>#include <Events.h>#include <Menus.h>#include <Windows.h>#include <TextEdit.h>#include <Dialogs.h>#include <OSUtils.h>#include <ToolUtils.h>#include <SegLoad.h>#include <Resources.h>#include <StandardFile.h>#include <stdlib.h>#include <stdio.h>#include <string.h>typedef struct{	long int offset;	long int size;	short id;	unsigned long int type; // not using FourLetterCode as this struct might be on windows too	unsigned char name[256];}ResourceInfo;void init(void);Boolean OpenResourceFile(const FSSpec* spec);void ResourceFileSuccessfullyOpened();void PrintFourCharCode(FourCharCode code);void PackIntoFile(FILE* file, FILE* offsetsFile);void DumpToFile(Handle handle, FILE* fptr, const ResourceInfo* info);void DumpOffsetToFile(FILE* offsetsFPtr, const ResourceInfo* info);void main(void){	StandardFileReply stdReply;	SFTypeList typeList = {'ACTU', 0, 0, 0};		init();		StandardGetFile(NULL, 1, typeList, &stdReply);	if(stdReply.sfGood){		printf("// %s                       \n", stdReply.sfFile.name);// why random characters?!		if(OpenResourceFile(&stdReply.sfFile)){			ResourceFileSuccessfullyOpened();		}		else{			printf("couldn't open resource file");		}	}}void init(){	InitFonts();	InitWindows();	InitMenus(); // miss one or more of these and it'll just crash and you'll have to restart the mac	InitDialogs(NULL);	InitResources();	FlushEvents(everyEvent,0);}Boolean OpenResourceFile(const FSSpec* spec){	short dataResHandle;	dataResHandle = FSpOpenResFile( spec, fsRdWrPerm);	if(ResError()==noErr){		UseResFile(dataResHandle);		return true;	}		return false;}void ResourceFileSuccessfullyOpened(){	FILE* dataFPtr;	FILE* offsetsFPtr;	if((dataFPtr = fopen("output.bin", "wb")) == NULL){		printf("Error opening output.bin");		exit(1);	}		if((offsetsFPtr = fopen("output.off", "wb")) == NULL){		printf("Error opening output.off");		exit(1);	}	PackIntoFile(dataFPtr, offsetsFPtr);	fclose(dataFPtr);	fclose(offsetsFPtr);}void PackIntoFile(FILE* fptr, FILE* offsetsFile){	// find types in resource file	int numTypes = Count1Types();	int i, j;	long int offset = 0;	for(i = 1; i <= numTypes; i++){ // looks wrong but isn't - it starts at 1		ResType type;		int numResources;		Get1IndType(&type, i);		PrintFourCharCode(type);		printf("\n");		// find resources of that type		numResources = Count1Resources(type);		for(j = 1; j <= numResources; j++){			ResourceInfo resInfo;			// get resource handle			Handle handle = Get1IndResource(type, j);						resInfo.offset = offset;			resInfo.size = GetResourceSizeOnDisk(handle);			GetResInfo(handle, &resInfo.id, &resInfo.type, resInfo.name);						printf("ID: %d         Size: %d         %s                  \n", resInfo.id, resInfo.size, resInfo.name);			DumpToFile(handle, fptr, &resInfo);			DumpOffsetToFile(offsetsFile, &resInfo);						offset += resInfo.size;			// release resourceHandle			ReleaseResource(handle);		}			}}void DumpOffsetToFile(FILE* offsetsFPtr, const ResourceInfo* info){	int i;	for(i=0; i<sizeof(ResourceInfo); i++){		fputc(((const char*)info)[i], offsetsFPtr);	}}void DumpToFile(Handle handle, FILE* fptr, const ResourceInfo* info){	if(info->id >= 0){		int k;				const char* input = (const char*)*handle;		for(k=0; k<info->size; k++){			fputc(input[k], fptr);		}	}	else{		//printf("id %i      IS < 0!", id);	}}void PrintFourCharCode(FourCharCode code){	printf("// ");	putchar((code >> 24) & 0xff);	putchar((code >> 16) & 0xff);	putchar((code >> 8) & 0xff);	putchar(code & 0xff);	printf("\n");}